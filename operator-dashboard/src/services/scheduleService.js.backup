// operator-dashboard/src/services/scheduleService.js - TEMPLATE-FIRST CLEAN BREAK
import { supabase } from '../lib/supabase'

// Local timezone helpers to avoid modifying shared timezone.js
const POLYNESIA_TZ = 'Pacific/Tahiti' // UTC-10

const parsePolynesianDate = (dateString) => {
  if (!dateString) return null
  // Split date string and create date in Polynesian timezone
  const [year, month, day] = dateString.split('-').map(Number)
  return new Date(year, month - 1, day) // month is 0-indexed
}

const formatPolynesianDateISO = (date) => {
  if (!date) return ''
  // Format in Polynesian timezone, then convert to ISO format
  const formatted = new Date(date).toLocaleDateString("en-CA", {
    timeZone: POLYNESIA_TZ,
    year: 'numeric',
    month: '2-digit', 
    day: '2-digit'
  })
  return formatted // en-CA locale gives YYYY-MM-DD format
}

// Removed unused date formatting function

export const scheduleService = {
  /**
   * Get all schedules for the authenticated operator
   * @param {string} operatorId - The operator's ID
   * @returns {Promise<Array>} Array of schedule records
   */
  async getSchedules(operatorId) {
    try {
      // Use the new schedule_details view for clean data access (TEMPLATE-FIRST APPROACH)
      const { data: schedules, error: schedulesError } = await supabase
        .from('schedule_details')
        .select('*')
        .eq('operator_id', operatorId)
        .eq('schedule_type', 'template_based') // Only template-based schedules
        .order('created_at', { ascending: false })

      if (schedulesError) {
        console.error('Error fetching template-based schedules:', schedulesError)
        throw schedulesError
      }

      if (!schedules || schedules.length === 0) {
        return []
      }

      // Map to consistent format for backward compatibility
      const mappedSchedules = schedules.map(schedule => ({
        id: schedule.id,
        operator_id: schedule.operator_id,
        schedule_type: schedule.schedule_type,
        recurrence_type: schedule.recurrence_type,
        days_of_week: schedule.days_of_week,
        start_time: schedule.start_time,
        start_date: schedule.start_date,
        end_date: schedule.end_date,
        exceptions: schedule.exceptions,
        created_at: schedule.created_at,
        updated_at: schedule.updated_at,
        // Template data (replaces legacy tours field)
        activity_templates: {
          id: schedule.template_id,
          activity_name: schedule.template_name,
          activity_type: schedule.template_type,
          max_capacity: schedule.template_capacity,
          discount_price_adult: schedule.template_price,
          status: schedule.template_status,
          auto_close_hours: schedule.auto_close_hours
        }
      }))

      return mappedSchedules
    } catch (error) {
      console.error('Error in getSchedules:', error)
      throw error
    }
  },

  // REMOVED: createSchedule - Legacy method for direct tour scheduling
  // Use createActivityTemplateSchedule instead for template-first workflow

  /**
   * ‚úÖ PHASE 3: Update an existing schedule with edge case protection
   */
  async updateSchedule(scheduleId, updateData, operatorId) {
    try {
      console.log('üîÑ Updating schedule:', scheduleId)

      // Step 1: Verify schedule exists and belongs to active operator
      const { data: existingSchedule, error: fetchError } = await supabase
        .from('schedules')
        .select('*')
        .eq('id', scheduleId)
        .eq('operator_id', operatorId)
        .single()

      if (fetchError || !existingSchedule) {
        console.error('Schedule fetch error:', fetchError)
        throw new Error('SCHEDULE_NOT_FOUND_OR_ACCESS_DENIED')
      }

      // Step 1b: Get related tour/template data separately to handle both cases
      const { data: relatedTour, error: tourError } = await supabase
        .from('tours')
        .select(`
          id, operator_id, tour_name, status, is_template, auto_close_hours, booking_deadline,
          tour_type, description, max_capacity, original_price_adult, discount_price_adult, 
          discount_price_child, meeting_point, location, meeting_point_gps, duration_hours,
          pickup_available, equipment_included, food_included, drinks_included,
          whale_regulation_compliant, weather_dependent, pickup_locations, languages,
          max_whale_group_size, min_age, max_age, fitness_level, requirements, restrictions
        `)
        .eq('id', existingSchedule.template_id)
        .single()

      if (tourError || !relatedTour) {
        console.error('Related tour/template fetch error:', tourError)
        throw new Error('LINKED_TOUR_OR_TEMPLATE_NOT_FOUND')
      }

      // Step 2: üõ°Ô∏è EDGE CASE - Check if schedule has active bookings
      const activeBookingsCheck = await this.checkActiveBookings(scheduleId)
      if (!activeBookingsCheck.canModify) {
        throw new Error(`SCHEDULE_HAS_ACTIVE_BOOKINGS|${activeBookingsCheck.count}`)
      }

      // Step 3: üõ°Ô∏è EDGE CASE - Verify linked template is still active (TEMPLATE-FIRST)
      if (relatedTour.status !== 'active') {
        throw new Error(`LINKED_TEMPLATE_INACTIVE|${relatedTour.status}`)
      }

      // Step 4: Enhanced validation with template data (always template-based now)
      let validationData = { ...existingSchedule, ...updateData }
      
      // Use template-specific validation (all schedules are template-based)
      validationData.auto_close_hours = relatedTour.auto_close_hours || 2
      validationData.booking_deadline = relatedTour.booking_deadline
      validationData.template_id = relatedTour.id // Add template_id for validation
      
      const validation = this.validateActivityTemplateScheduleData(validationData, relatedTour)
      if (!validation.valid) {
        throw new Error(`VALIDATION_FAILED|${validation.errors.join('|')}`)
      }

      // Step 5: Prepare update data (only allow certain fields)
      const allowedFields = ['recurrence_type', 'days_of_week', 'start_time', 'start_date', 'end_date', 'exceptions']
      const filteredUpdateData = Object.keys(updateData)
        .filter(key => allowedFields.includes(key))
        .reduce((obj, key) => {
          obj[key] = updateData[key]
          return obj
        }, {})

      // Add updated_at timestamp
      filteredUpdateData.updated_at = new Date().toISOString()

      // Step 6: Update in database
      const { data: updatedSchedule, error: updateError } = await supabase
        .from('schedules')
        .update(filteredUpdateData)
        .eq('id', scheduleId)
        .eq('operator_id', operatorId)
        .select()
        .single()

      if (updateError) {
        console.error('Error updating schedule:', updateError)
        throw new Error(`DATABASE_UPDATE_FAILED|${updateError.message}`)
      }

      console.log('‚úÖ Schedule updated successfully:', scheduleId)
      
      // Step 7: INTELLIGENT DIFFERENTIAL UPDATE - Industry Standard Approach
      // Preserve customizations, update only what changed, avoid data loss
      {
        console.log('üîÑ Applying intelligent differential update to activity instances...')
        
        try {
          // Prepare updated schedule data
          const mergedScheduleData = {
            ...existingSchedule,
            ...filteredUpdateData,
            template_id: existingSchedule.template_id,
            id: scheduleId
          }
          
          // Get existing tours for this schedule
          const { data: existingTours, error: fetchError } = await supabase
            .from('tours')
            .select('id, tour_date, time_slot, is_customized, customization_timestamp, overrides, frozen_fields')
            .eq('parent_schedule_id', scheduleId)
            .eq('activity_type', 'scheduled')
            .order('tour_date', { ascending: true })
          
          if (fetchError) {
            console.error('Error fetching existing tours:', fetchError)
            throw new Error(`EXISTING_TOURS_FETCH_FAILED: ${fetchError.message}`)
          }
          
          // Generate new schedule dates
          const newDates = this.generateDatesFromSchedule(mergedScheduleData)
          const newTime = mergedScheduleData.start_time
          
          console.log(`üìä Schedule update analysis:`, {
            existing_tours: existingTours?.length || 0,
            customized_tours: existingTours?.filter(t => t.is_customized).length || 0,
            new_schedule_dates: newDates.length,
            time_change: existingSchedule.start_time !== newTime ? `${existingSchedule.start_time} ‚Üí ${newTime}` : 'no change'
          })
          
          // STEP 1: Identify tours to keep, update, and remove
          const existingDatesMap = new Map()
          const customizedTours = []
          const nonCustomizedTours = []
          
          existingTours?.forEach(tour => {
            existingDatesMap.set(tour.tour_date, tour)
            if (tour.is_customized) {
              customizedTours.push(tour)
            } else {
              nonCustomizedTours.push(tour)
            }
          })
          
          // STEP 2: Process each category intelligently
          const toursToRemove = []
          const toursToUpdate = []
          const datesToAdd = []
          
          // Identify obsolete tours (dates no longer in schedule)
          existingTours?.forEach(tour => {
            if (!newDates.includes(tour.tour_date)) {
              if (tour.is_customized) {
                console.log(`‚ö†Ô∏è Customized tour on obsolete date ${tour.tour_date} - keeping but marking as detached`)
                // Keep customized tours even if date is removed, but detach them
                toursToUpdate.push({
                  id: tour.id,
                  is_detached: true,
                  updated_at: new Date().toISOString()
                })
              } else {
                console.log(`üóëÔ∏è Removing non-customized tour on obsolete date ${tour.tour_date}`)
                toursToRemove.push(tour.id)
              }
            }
          })
          
          // Identify dates that need new tours
          newDates.forEach(date => {
            if (!existingDatesMap.has(date)) {
              datesToAdd.push(date)
            }
          })
          
          // Identify existing tours that need time updates (non-customized only)
          nonCustomizedTours.forEach(tour => {
            if (newDates.includes(tour.tour_date) && tour.time_slot !== newTime) {
              console.log(`üîÑ Updating time for non-customized tour ${tour.tour_date}: ${tour.time_slot} ‚Üí ${newTime}`)
              toursToUpdate.push({
                id: tour.id,
                time_slot: newTime,
                updated_at: new Date().toISOString()
              })
            }
          })
          
          console.log(`üìã Differential update plan:`, {
            tours_to_remove: toursToRemove.length,
            tours_to_update: toursToUpdate.length, 
            dates_to_add: datesToAdd.length,
            customized_tours_preserved: customizedTours.length
          })
          
          // STEP 3: Execute the differential update
          let operationsCompleted = 0
          
          // Remove obsolete non-customized tours
          if (toursToRemove.length > 0) {
            const { error: removeError } = await supabase
              .from('tours')
              .delete()
              .in('id', toursToRemove)
            
            if (removeError) {
              console.warn('Warning: Could not remove some obsolete tours:', removeError)
            } else {
              console.log(`‚úÖ Removed ${toursToRemove.length} obsolete tours`)
              operationsCompleted++
            }
          }
          
          // Update existing tours (time changes, detachment)
          if (toursToUpdate.length > 0) {
            for (const update of toursToUpdate) {
              const { error: updateError } = await supabase
                .from('tours')
                .update(update)
                .eq('id', update.id)
              
              if (updateError) {
                console.warn(`Warning: Could not update tour ${update.id}:`, updateError)
              }
            }
            console.log(`‚úÖ Updated ${toursToUpdate.length} existing tours`)
            operationsCompleted++
          }
          
          // Add new tours for new dates
          if (datesToAdd.length > 0) {
            const newTours = []
            for (const date of datesToAdd) {
              const tourData = {
                // Core identification
                operator_id: relatedTour.operator_id,
                tour_name: relatedTour.tour_name,
                tour_type: relatedTour.tour_type,
                description: relatedTour.description,
                
                // Schedule-specific fields
                tour_date: date,
                time_slot: newTime,
                activity_type: 'scheduled',
                is_template: false,
                parent_template_id: relatedTour.id,
                parent_schedule_id: scheduleId,
                
                // Template data
                max_capacity: relatedTour.max_capacity,
                available_spots: relatedTour.max_capacity,
                original_price_adult: relatedTour.original_price_adult,
                discount_price_adult: relatedTour.discount_price_adult,
                discount_price_child: relatedTour.discount_price_child,
                meeting_point: relatedTour.meeting_point || 'Meeting Point TBD',
                location: relatedTour.location,
                meeting_point_gps: relatedTour.meeting_point_gps,
                duration_hours: relatedTour.duration_hours,
                pickup_available: relatedTour.pickup_available || false,
                equipment_included: relatedTour.equipment_included || false,
                food_included: relatedTour.food_included || false,
                drinks_included: relatedTour.drinks_included || false,
                whale_regulation_compliant: relatedTour.whale_regulation_compliant || false,
                weather_dependent: relatedTour.weather_dependent !== undefined ? relatedTour.weather_dependent : true,
                pickup_locations: relatedTour.pickup_locations,
                languages: relatedTour.languages || ['French'],
                max_whale_group_size: relatedTour.max_whale_group_size || 6,
                min_age: relatedTour.min_age,
                max_age: relatedTour.max_age,
                fitness_level: relatedTour.fitness_level,
                requirements: relatedTour.requirements,
                restrictions: relatedTour.restrictions,
                status: relatedTour.status || 'active',
                booking_deadline: relatedTour.booking_deadline,
                auto_close_hours: relatedTour.auto_close_hours || 2,
                backup_plan: relatedTour.backup_plan,
                special_notes: relatedTour.special_notes,
                created_by_operator: true
              }
              newTours.push(tourData)
            }
            
            const { data: insertedTours, error: insertError } = await supabase
              .from('tours')
              .insert(newTours)
              .select('id, tour_date')
            
            if (insertError) {
              console.error('Error adding new tours:', insertError)
              throw new Error(`NEW_TOURS_INSERT_FAILED: ${insertError.message}`)
            }
            
            console.log(`‚úÖ Added ${insertedTours?.length || 0} new tours for new dates`)
            operationsCompleted++
          }
          
          console.log(`üéâ Intelligent differential update completed: ${operationsCompleted} operations executed`)
          console.log(`üìä Final state: ${customizedTours.length} customized tours preserved, schedule updated successfully`)
          
        } catch (differentialUpdateError) {
          console.error('‚ùå CRITICAL: Differential update failed:', differentialUpdateError)
          throw new Error(`DIFFERENTIAL_UPDATE_FAILED: ${differentialUpdateError.message}`)
        }
      }
      
      return updatedSchedule

    } catch (error) {
      console.error('Error in updateSchedule:', error)
      throw error
    }
  },

  /**
   * ‚úÖ PHASE 3: Delete a schedule with comprehensive checks
   */
  async deleteSchedule(scheduleId, operatorId) {
    try {
      console.log('üóëÔ∏è Deleting schedule:', scheduleId)

      // Step 1: Verify schedule exists and belongs to operator
      const { data: existingSchedule, error: fetchError } = await supabase
        .from('schedules')
        .select('id, tour_id')
        .eq('id', scheduleId)
        .eq('operator_id', operatorId)
        .single()

      if (fetchError || !existingSchedule) {
        throw new Error('SCHEDULE_NOT_FOUND_OR_ACCESS_DENIED')
      }

      // Step 2: üõ°Ô∏è EDGE CASE - Check for active bookings
      const { data: activeBookings, error: bookingsError } = await supabase
        .from('bookings')
        .select('id, booking_status, commission_locked_at')
        .eq('schedule_id', scheduleId)
        .in('booking_status', ['pending', 'confirmed'])

      if (bookingsError) {
        console.error('Error checking active bookings:', bookingsError)
        throw new Error(`BOOKINGS_CHECK_FAILED|${bookingsError.message}`)
      }

      if (activeBookings && activeBookings.length > 0) {
        // Check for commission-locked bookings (extra protection)
        const lockedBookings = activeBookings.filter(b => b.commission_locked_at)
        if (lockedBookings.length > 0) {
          throw new Error(`SCHEDULE_HAS_LOCKED_BOOKINGS|${lockedBookings.length}`)
        }
        throw new Error(`SCHEDULE_HAS_ACTIVE_BOOKINGS|${activeBookings.length}`)
      }

      // Step 3: Delete the schedule (will set bookings.schedule_id to NULL due to ON DELETE SET NULL)
      const { error: deleteError } = await supabase
        .from('schedules')
        .delete()
        .eq('id', scheduleId)
        .eq('operator_id', operatorId)

      if (deleteError) {
        console.error('Error deleting schedule:', deleteError)
        throw new Error(`DATABASE_DELETE_FAILED|${deleteError.message}`)
      }

      console.log('‚úÖ Schedule deleted successfully:', scheduleId)
      return true

    } catch (error) {
      console.error('Error in deleteSchedule:', error)
      throw error
    }
  },

  /**
   * ‚úÖ PHASE 3: Duplicate an existing schedule with smart overrides
   */
  async duplicateSchedule(scheduleId, operatorId, overrides = {}) {
    try {
      console.log('üìã Duplicating schedule:', scheduleId)

      // Step 1: Get original schedule with tour data
      const { data: originalSchedule, error: fetchError } = await supabase
        .from('schedules')
        .select('*, tours!inner(id, tour_name, status)')
        .eq('id', scheduleId)
        .eq('operator_id', operatorId)
        .single()

      if (fetchError || !originalSchedule) {
        throw new Error('SCHEDULE_NOT_FOUND_OR_ACCESS_DENIED')
      }

      // Step 2: üõ°Ô∏è EDGE CASE - Verify original tour is still active
      if (originalSchedule.tours.status !== 'active') {
        throw new Error(`ORIGINAL_TOUR_INACTIVE|${originalSchedule.tours.status}`)
      }

      // Step 3: Prepare duplicate data with smart defaults
      const duplicateData = {
        tour_id: originalSchedule.tour_id,
        operator_id: originalSchedule.operator_id,
        recurrence_type: originalSchedule.recurrence_type,
        days_of_week: originalSchedule.days_of_week,
        start_time: originalSchedule.start_time,
        start_date: originalSchedule.start_date,
        end_date: originalSchedule.end_date,
        exceptions: originalSchedule.exceptions,
        ...overrides // Apply any overrides (e.g., new dates, different tour)
      }

      // Step 4: Create the duplicate using createSchedule (includes all validation + edge case handling)
      const duplicatedSchedule = await this.createSchedule(duplicateData)

      console.log('‚úÖ Schedule duplicated successfully:', duplicatedSchedule.id)
      return duplicatedSchedule

    } catch (error) {
      console.error('Error in duplicateSchedule:', error)
      throw error
    }
  },

  /**
   * Get active activity templates for schedule creation (UNIFIED TABLE APPROACH)
   * @param {string} operatorId - The operator ID
   * @returns {Promise<Object>} Activity templates data or error
   */
  async getOperatorActivityTemplates(operatorId) {
    try {
      const { data: templates, error } = await supabase
        .from('tours')
        .select(`
          id,
          tour_name,
          tour_type,
          duration_hours,
          max_capacity,
          original_price_adult,
          discount_price_adult,
          location,
          status,
          auto_close_hours,
          booking_deadline
        `)
        .eq('operator_id', operatorId)
        .eq('is_template', true)
        .eq('status', 'active')
        .order('tour_name', { ascending: true })

      if (error) {
        console.error('Error fetching operator activity templates:', error)
        throw error
      }

      // Map to consistent field names for backward compatibility
      const mappedTemplates = (templates || []).map(template => ({
        ...template,
        activity_name: template.tour_name,
        activity_type: template.tour_type,
        island_location: template.location
      }))

      return { data: mappedTemplates, error: null }
    } catch (error) {
      console.error('Error in getOperatorActivityTemplates:', error)
      return { data: null, error }
    }
  },

  /**
   * Create a schedule linked to an activity template
   * @param {Object} scheduleData - The schedule data including template_id
   * @returns {Promise<Object>} Created schedule record
   */
  async createActivityTemplateSchedule(scheduleData) {
    try {
      console.log('üöÄ Creating activity template schedule with data:', scheduleData)

      // Step 1: Verify operator status and permissions
      const { data: operator, error: operatorError } = await supabase
        .from('operators')
        .select('id, status')
        .eq('id', scheduleData.operator_id)
        .single()

      if (operatorError || !operator) {
        throw new Error('OPERATOR_NOT_FOUND')
      }

      if (operator.status !== 'active') {
        throw new Error(`OPERATOR_INACTIVE|${operator.status}`)
      }

      // Step 2: Verify activity template exists and belongs to operator (UNIFIED TABLE APPROACH)
      const { data: template, error: templateError } = await supabase
        .from('tours')
        .select(`
          id, tour_name, operator_id, status, is_template, auto_close_hours, booking_deadline,
          tour_type, description, max_capacity, original_price_adult, discount_price_adult, 
          discount_price_child, meeting_point, location, meeting_point_gps, duration_hours,
          pickup_available, equipment_included, food_included, drinks_included,
          whale_regulation_compliant, weather_dependent, pickup_locations, languages,
          max_whale_group_size, min_age, max_age, fitness_level, requirements, restrictions
        `)
        .eq('id', scheduleData.template_id)
        .eq('operator_id', scheduleData.operator_id)
        .eq('is_template', true)
        .single()

      if (templateError || !template) {
        throw new Error('TEMPLATE_NOT_FOUND_OR_ACCESS_DENIED')
      }

      if (template.status !== 'active') {
        throw new Error(`TEMPLATE_INACTIVE|${template.status}`)
      }

      // Step 3: Enhanced validation with template data (including auto-close hours)
      const enhancedScheduleData = {
        ...scheduleData,
        auto_close_hours: template.auto_close_hours || 2,
        booking_deadline: template.booking_deadline
      }
      
      const validation = this.validateActivityTemplateScheduleData(enhancedScheduleData, template)
      if (!validation.valid) {
        throw new Error(`VALIDATION_FAILED|${validation.errors.join('|')}`)
      }

      // Step 4: Check for schedule conflicts with existing templates
      const conflictCheck = await this.checkTemplateScheduleConflicts(scheduleData, template)
      if (!conflictCheck.valid) {
        throw new Error(`SCHEDULE_CONFLICT|${conflictCheck.reason}`)
      }

      // Step 5: Prepare data for insertion (CLEAN TEMPLATE-FIRST APPROACH)
      const insertData = {
        template_id: scheduleData.template_id, // Store template ID in dedicated template_id column
        schedule_type: 'template_based', // Explicitly mark as template-based schedule
        operator_id: scheduleData.operator_id,
        recurrence_type: scheduleData.recurrence_type,
        days_of_week: scheduleData.days_of_week || null,
        start_time: scheduleData.start_time,
        start_date: scheduleData.start_date,
        end_date: scheduleData.end_date,
        exceptions: scheduleData.exceptions || null
        // NOTE: tour_id is left as NULL for template-based schedules
      }

      // Step 6: Insert into database
      const { data: newSchedule, error: insertError } = await supabase
        .from('schedules')
        .insert(insertData)
        .select()
        .single()

      if (insertError) {
        console.error('Error inserting activity template schedule:', insertError)
        throw new Error(`DATABASE_INSERT_FAILED|${insertError.message}`)
      }

      console.log('‚úÖ Activity template schedule created successfully:', newSchedule.id)

      // Step 7: AUTOMATICALLY GENERATE SCHEDULED TOURS (UNIFIED TABLE APPROACH)
      console.log('üîÑ About to generate scheduled tours with data:', {
        templateId: template.id,
        templateName: template.tour_name,
        scheduleData: {
          start_date: scheduleData.start_date,
          end_date: scheduleData.end_date,
          recurrence_type: scheduleData.recurrence_type,
          days_of_week: scheduleData.days_of_week,
          start_time: scheduleData.start_time
        }
      })
      
      // Add the newly created schedule ID to the schedule data for tour generation
      const scheduleDataWithId = {
        ...scheduleData,
        id: newSchedule.id
      }
      
      const scheduledTours = await this.generateScheduledToursFromTemplate(template, scheduleDataWithId)
      
      console.log(`‚úÖ Generated ${scheduledTours.length} scheduled tours from template`)
      console.log('üìã Generated tours details:', scheduledTours.map(t => ({
        id: t.id,
        tour_name: t.tour_name,
        activity_type: t.activity_type,
        tour_date: t.tour_date,
        time_slot: t.time_slot,
        status: t.status
      })))

      // Step 8: Return schedule with template data and generated tours count
      return {
        ...newSchedule,
        activity_templates: {
          id: template.id,
          activity_name: template.tour_name,
          status: template.status
        },
        generated_tours_count: scheduledTours.length,
        first_tour_date: scheduledTours[0]?.tour_date,
        last_tour_date: scheduledTours[scheduledTours.length - 1]?.tour_date
      }

    } catch (error) {
      console.error('Error in createActivityTemplateSchedule:', error)
      throw error
    }
  },

  /**
   * Generate scheduled tours from template (Unified Table Approach)
   * Creates actual bookable tours from template + schedule data
   */
  async generateScheduledToursFromTemplate(template, scheduleData) {
    try {
      const dates = this.generateDatesFromSchedule(scheduleData)
      const scheduledTours = []

      for (const date of dates) {
        // Create scheduled tour based on template - COMPREHENSIVE DATA COPYING
        const scheduledTourData = {
          // Core identification
          operator_id: template.operator_id,
          tour_name: template.tour_name,
          tour_type: template.tour_type || 'Lagoon Tour',
          description: template.description,
          
          // Schedule-specific fields
          tour_date: date,
          time_slot: scheduleData.start_time,
          activity_type: 'scheduled',
          is_template: false,
          parent_template_id: template.id,
          parent_schedule_id: scheduleData.id, // Critical for RLS policy compliance
          
          // Capacity and availability
          max_capacity: template.max_capacity || 1,
          available_spots: template.max_capacity || 1,
          
          // Pricing - CRITICAL FIX
          original_price_adult: template.original_price_adult || 0,
          discount_price_adult: template.discount_price_adult || template.original_price_adult || 0,
          discount_price_child: template.discount_price_child || 0,
          
          // Location and logistics - CRITICAL FIX: meeting_point is NOT NULL in schema
          meeting_point: template.meeting_point || 'Meeting Point TBD',
          location: template.location,
          meeting_point_gps: template.meeting_point_gps,
          
          // Tour details
          duration_hours: template.duration_hours,
          
          // Boolean features
          pickup_available: template.pickup_available || false,
          equipment_included: template.equipment_included || false,
          food_included: template.food_included || false,
          drinks_included: template.drinks_included || false,
          whale_regulation_compliant: template.whale_regulation_compliant || false,
          weather_dependent: template.weather_dependent !== undefined ? template.weather_dependent : true,
          
          // Arrays
          pickup_locations: template.pickup_locations || null,
          languages: template.languages || ['French'],
          
          // Constraints and requirements
          max_whale_group_size: template.max_whale_group_size || 6,
          min_age: template.min_age,
          max_age: template.max_age,
          fitness_level: template.fitness_level,
          requirements: template.requirements,
          restrictions: template.restrictions,
          
          // Business logic
          status: template.status || 'active',
          booking_deadline: template.booking_deadline,
          auto_close_hours: template.auto_close_hours || 2,
          backup_plan: template.backup_plan,
          special_notes: template.special_notes,
          created_by_operator: true
        }
        
        console.log('üîß Creating scheduled tour with data:', {
          tour_name: scheduledTourData.tour_name,
          tour_type: scheduledTourData.tour_type,
          activity_type: scheduledTourData.activity_type,
          tour_date: scheduledTourData.tour_date,
          time_slot: scheduledTourData.time_slot,
          status: scheduledTourData.status,
          max_capacity: scheduledTourData.max_capacity,
          available_spots: scheduledTourData.available_spots,
          original_price_adult: scheduledTourData.original_price_adult,
          discount_price_adult: scheduledTourData.discount_price_adult,
          discount_price_child: scheduledTourData.discount_price_child,
          meeting_point: scheduledTourData.meeting_point
        })

        // CRITICAL DEBUG: Auth and RLS context analysis
        console.log('üîç AUTH DEBUG - About to INSERT tour:', {
          operator_id_from_tour_data: scheduledTourData.operator_id,
          template_operator_id: template.operator_id,
          schedule_operator_id: scheduleData.operator_id,
          parent_template_id: scheduledTourData.parent_template_id,
          parent_schedule_id: scheduledTourData.parent_schedule_id,
          activity_type: scheduledTourData.activity_type,
          is_template: scheduledTourData.is_template,
          template_id_from_template: template.id,
          schedule_id_from_schedule_data: scheduleData.id
        })
        
        // Additional auth context check
        console.log('üîç RLS POLICY CHECK - Expected vs Actual:', {
          expected_pattern: 'auth.uid() should match operators.auth_user_id where operators.id = tour.operator_id',
          tour_operator_id: scheduledTourData.operator_id,
          template_source: 'template.operator_id',
          schedule_source: 'scheduleData.operator_id',
          note: 'RLS policy will check if current auth.uid() matches operator with this operator_id'
        })

        const { data: scheduledTour, error } = await supabase
          .from('tours')
          .insert(scheduledTourData)
          .select()
          .single()

        if (error) {
          console.error('Error creating scheduled tour:', error)
          throw error
        }

        scheduledTours.push(scheduledTour)
      }

      return scheduledTours

    } catch (error) {
      console.error('Error generating scheduled tours:', error)
      throw error
    }
  },

  /**
   * Generate dates from schedule configuration
   */
  generateDatesFromSchedule(scheduleData) {
    console.log('üìÖ Generating dates from schedule:', {
      start_date: scheduleData.start_date,
      end_date: scheduleData.end_date,
      recurrence_type: scheduleData.recurrence_type,
      days_of_week: scheduleData.days_of_week,
      exceptions: scheduleData.exceptions
    })
    
    const dates = []
    // FIX: Create dates in Polynesian timezone to avoid UTC conversion issues
    const startDate = new Date(scheduleData.start_date + 'T12:00:00')  // Noon to avoid timezone shifts
    const endDate = new Date(scheduleData.end_date + 'T12:00:00')      // Noon to avoid timezone shifts
    
    // FIX: Normalize exception dates to avoid timezone issues
    const exceptions = (scheduleData.exceptions || []).map(exceptionDate => {
      // Ensure exception dates are in YYYY-MM-DD format without time/timezone confusion
      if (typeof exceptionDate === 'string' && exceptionDate.includes('T')) {
        return exceptionDate.split('T')[0]  // Remove time part if present
      }
      return exceptionDate
    })
    
    console.log('üîç Normalized exceptions:', exceptions)

    if (scheduleData.recurrence_type === 'once') {
      dates.push(scheduleData.start_date)
    } else if (scheduleData.recurrence_type === 'daily') {
      let currentDate = new Date(startDate)
      while (currentDate <= endDate) {
        // FIX: Use proper date formatting to avoid timezone shift
        const year = currentDate.getFullYear()
        const month = String(currentDate.getMonth() + 1).padStart(2, '0')
        const day = String(currentDate.getDate()).padStart(2, '0')
        const dateStr = `${year}-${month}-${day}`
        if (!exceptions.includes(dateStr)) {
          dates.push(dateStr)
        }
        currentDate.setDate(currentDate.getDate() + 1)
      }
    } else if (scheduleData.recurrence_type === 'weekly') {
      console.log('üîç Weekly recurrence - days_of_week array:', scheduleData.days_of_week)
      console.log('üîç Array element types:', scheduleData.days_of_week.map(d => typeof d))
      
      let currentDate = new Date(startDate)
      while (currentDate <= endDate) {
        const dayOfWeek = currentDate.getDay() === 0 ? 7 : currentDate.getDay() // Convert Sunday=0 to Sunday=7
        const dayOfWeekString = String(dayOfWeek)
        const dayOfWeekNumber = Number(dayOfWeek)
        
        // FIX: Use proper date formatting to avoid timezone shift
        const year = currentDate.getFullYear()
        const month = String(currentDate.getMonth() + 1).padStart(2, '0')
        const day = String(currentDate.getDate()).padStart(2, '0')
        const dateStr = `${year}-${month}-${day}`
        
        // Only log first few checks to avoid console spam
        if (dates.length < 3) {
          console.log(`üîç Checking date ${dateStr} (day ${dayOfWeek}):`, {
            dayOfWeek,
            dayOfWeekString,
            dayOfWeekNumber,
            arrayIncludes_String: scheduleData.days_of_week.includes(dayOfWeekString),
            arrayIncludes_Number: scheduleData.days_of_week.includes(dayOfWeekNumber),
            daysArray: scheduleData.days_of_week
          })
        }
        
        // Try both string and number formats
        if (scheduleData.days_of_week.includes(String(dayOfWeek)) || scheduleData.days_of_week.includes(Number(dayOfWeek))) {
          if (!exceptions.includes(dateStr)) {
            console.log(`‚úÖ Adding date: ${dateStr}`)
            dates.push(dateStr)
          }
        }
        currentDate.setDate(currentDate.getDate() + 1)
      }
    }

    const sortedDates = dates.sort()
    console.log(`üìÖ Generated ${sortedDates.length} dates:`, sortedDates)
    return sortedDates
  },

  /**
   * Get schedules with activity template information (UNIFIED TABLE APPROACH)
   * @param {string} operatorId - The operator's ID
   * @returns {Promise<Array>} Array of schedule records with template data
   */
  async getSchedulesWithTemplates(operatorId) {
    try {
      // Use the new schedule_details view for comprehensive template data (TEMPLATE-FIRST APPROACH)
      const { data: schedules, error: schedulesError } = await supabase
        .from('schedule_details')
        .select('*')
        .eq('operator_id', operatorId)
        .eq('schedule_type', 'template_based') // Only template-based schedules
        .order('created_at', { ascending: false })

      if (schedulesError) {
        console.error('Error fetching schedules with templates:', schedulesError)
        throw schedulesError
      }

      if (!schedules || schedules.length === 0) {
        return []
      }

      // Map to expected format (template data is already joined in the view)
      const schedulesWithTemplates = schedules.map(schedule => ({
        id: schedule.id,
        operator_id: schedule.operator_id,
        schedule_type: schedule.schedule_type,
        recurrence_type: schedule.recurrence_type,
        days_of_week: schedule.days_of_week,
        start_time: schedule.start_time,
        start_date: schedule.start_date,
        end_date: schedule.end_date,
        exceptions: schedule.exceptions,
        created_at: schedule.created_at,
        updated_at: schedule.updated_at,
        // Template data from the joined view
        activity_templates: {
          id: schedule.template_id,
          activity_name: schedule.template_name,
          activity_type: schedule.template_type,
          max_capacity: schedule.template_capacity,
          discount_price_adult: schedule.template_price,
          status: schedule.template_status,
          island_location: schedule.template_location || schedule.location,
          auto_close_hours: schedule.auto_close_hours
        }
      }))

      return schedulesWithTemplates
    } catch (error) {
      console.error('Error in getSchedulesWithTemplates:', error)
      throw error
    }
  },

  // REMOVED: generateActivityInstances - obsolete in unified table approach
  // Tours are generated automatically during schedule creation

  /**
   * Check for schedule conflicts with activity templates
   * @param {Object} scheduleData - New schedule data
   * @param {Object} template - Activity template data
   * @returns {Promise<Object>} Conflict check result
   */
  async checkTemplateScheduleConflicts(scheduleData, template) {
    try {
      // Check for existing template-based schedules with same template + time that might conflict
      const { data: existingSchedules, error } = await supabase
        .from('schedules')
        .select('id, recurrence_type, start_time, start_date, end_date, days_of_week, exceptions')
        .eq('template_id', scheduleData.template_id) // Use template_id instead of tour_id
        .eq('schedule_type', 'template_based') // Only check template-based schedules
        .eq('start_time', scheduleData.start_time)

      if (error) {
        console.error('Error checking template schedule conflicts:', error)
        return { valid: true } // Allow on error, logged for monitoring
      }

      if (!existingSchedules || existingSchedules.length === 0) {
        return { valid: true }
      }

      // Use existing conflict detection logic
      for (const existing of existingSchedules) {
        const conflict = this.detectDateTimeConflict(scheduleData, existing)
        if (conflict.hasConflict) {
          return { 
            valid: false, 
            reason: `TEMPLATE_SCHEDULE_CONFLICT|${existing.id}|${conflict.conflictDate}` 
          }
        }
      }

      return { valid: true }

    } catch (error) {
      console.error('Error in checkTemplateScheduleConflicts:', error)
      return { valid: true } // Allow on error
    }
  },

  /**
   * Validation for activity template schedule data
   * @param {Object} scheduleData - The schedule data to validate
   * @param {Object} template - The template data for enhanced validation (optional)
   * @returns {Object} Validation result
   */
  validateActivityTemplateScheduleData(scheduleData, template = null) {
    const errors = []

    try {
      // Required fields validation for templates
      if (!scheduleData.template_id) errors.push('TEMPLATE_ID_REQUIRED')
      if (!scheduleData.operator_id) errors.push('OPERATOR_ID_REQUIRED')

      // Template-specific validation (excluding tour_id requirement)
      if (!scheduleData.recurrence_type) {
        errors.push('RECURRENCE_TYPE_REQUIRED')
      }

      if (!scheduleData.start_time) {
        errors.push('START_TIME_REQUIRED')
      }

      if (!scheduleData.start_date) {
        errors.push('START_DATE_REQUIRED')
      }

      if (!scheduleData.end_date) {
        errors.push('END_DATE_REQUIRED')
      }

      // Recurrence type validation
      const validRecurrenceTypes = ['once', 'daily', 'weekly', 'monthly']
      if (scheduleData.recurrence_type && !validRecurrenceTypes.includes(scheduleData.recurrence_type)) {
        errors.push('INVALID_RECURRENCE_TYPE')
      }

      // Days of week validation
      if (scheduleData.days_of_week) {
        if (!Array.isArray(scheduleData.days_of_week)) {
          errors.push('DAYS_OF_WEEK_MUST_BE_ARRAY')
        } else {
          const invalidDays = scheduleData.days_of_week.filter(day => !Number.isInteger(day) || day < 1 || day > 7)
          if (invalidDays.length > 0) {
            errors.push('INVALID_DAYS_OF_WEEK')
          }
        }
      }

      // Weekly recurrence requires days_of_week
      if (scheduleData.recurrence_type === 'weekly' && (!scheduleData.days_of_week || scheduleData.days_of_week.length === 0)) {
        errors.push('WEEKLY_REQUIRES_DAYS')
      }

      // Time format validation (HH:MM)
      if (scheduleData.start_time) {
        const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/
        if (!timeRegex.test(scheduleData.start_time)) {
          errors.push('INVALID_TIME_FORMAT')
        }
      }

      // Date format validation (YYYY-MM-DD)
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/

      if (scheduleData.start_date && !dateRegex.test(scheduleData.start_date)) {
        errors.push('INVALID_START_DATE_FORMAT')
      }

      if (scheduleData.end_date && !dateRegex.test(scheduleData.end_date)) {
        errors.push('INVALID_END_DATE_FORMAT')
      }

      // Date logic validation
      if (scheduleData.start_date && scheduleData.end_date) {
        const startDate = new Date(scheduleData.start_date)
        const endDate = new Date(scheduleData.end_date)
        const today = new Date()
        today.setHours(0, 0, 0, 0) // Reset time for date comparison

        // Skip basic past date check for templates - auto-close validation handles timing

        if (endDate <= startDate) {
          errors.push('END_DATE_BEFORE_START')
        }

        // Reasonable date range limits (2 years max)
        const maxDateRange = 365 * 2 * 24 * 60 * 60 * 1000 // 2 years in milliseconds
        if (endDate - startDate > maxDateRange) {
          errors.push('DATE_RANGE_TOO_LARGE')
        }
      }

      // Exceptions validation
      if (scheduleData.exceptions) {
        if (!Array.isArray(scheduleData.exceptions)) {
          errors.push('EXCEPTIONS_MUST_BE_ARRAY')
        } else {
          const invalidExceptions = scheduleData.exceptions.filter(date => !dateRegex.test(date))
          if (invalidExceptions.length > 0) {
            errors.push('INVALID_EXCEPTION_DATES')
          }
        }
      }

      // UUID format validation for template_id
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
      if (scheduleData.template_id && !uuidRegex.test(scheduleData.template_id)) {
        errors.push('INVALID_TEMPLATE_ID_FORMAT')
      }

      // Enhanced validation with auto-close hours for template schedules
      if (scheduleData.start_time && scheduleData.auto_close_hours !== undefined && scheduleData.start_date) {
        const currentDateTime = new Date()
        const [hours, minutes] = scheduleData.start_time.split(':').map(Number)
        
        // Check earliest schedule date with time (timezone-safe parsing)
        const [year, month, day] = scheduleData.start_date.split('-').map(Number)
        const earliestDateTime = new Date(year, month - 1, day, hours, minutes, 0, 0)
        
        // Calculate booking deadline = activity time - auto_close_hours
        const autoCloseHours = scheduleData.auto_close_hours || 2
        const bookingDeadline = new Date(earliestDateTime.getTime() - (autoCloseHours * 60 * 60 * 1000))
        
        console.log('üîç Backend validation:', {
          startDate: scheduleData.start_date,
          startTime: scheduleData.start_time,
          currentDateTime: currentDateTime.toLocaleString(),
          earliestDateTime: earliestDateTime.toLocaleString(),
          bookingDeadline: bookingDeadline.toLocaleString(),
          autoCloseHours,
          isPastDeadline: currentDateTime >= bookingDeadline
        })
        
        if (currentDateTime >= bookingDeadline) {
          errors.push(`BOOKING_DEADLINE_PASSED|${autoCloseHours}`)
        }
      }

    } catch (error) {
      errors.push(`VALIDATION_ERROR|${error.message}`)
    }

    return {
      valid: errors.length === 0,
      errors: errors
    }
  },

  /**
   * Generate preview of activity instances that would be created from template schedule
   * @param {Object} scheduleData - The schedule data with template_id
   * @param {number} limit - Maximum number of instances to preview
   * @returns {Promise<Array>} Array of preview instances with template details
   */
  async generateActivityTemplateSchedulePreview(scheduleData, limit = 10) {
    try {
      // Get base preview using existing logic
      const basePreview = this.generateSchedulePreview(scheduleData, limit)
      
      if (!scheduleData.template_id) {
        return basePreview
      }

      // Get template details for enhanced preview (UNIFIED TABLE APPROACH)
      const { data: template, error } = await supabase
        .from('tours')
        .select('id, tour_name, tour_type, max_capacity, discount_price_adult')
        .eq('id', scheduleData.template_id)
        .eq('is_template', true)
        .single()

      if (error) {
        console.error('Error fetching template for preview:', error)
        return basePreview
      }

      // Enhance preview with template information
      return basePreview.map(instance => ({
        ...instance,
        template: {
          id: template.id,
          activity_name: template.tour_name,
          activity_type: template.tour_type,
          max_capacity: template.max_capacity,
          price: template.discount_price_adult
        }
      }))

    } catch (error) {
      console.error('Error generating activity template schedule preview:', error)
      return []
    }
  },

  // REMOVED: getOperatorTours - Legacy method for fetching tours directly
  // Use getOperatorActivityTemplates instead for template-first workflow

  // REMOVED: checkScheduleConflicts - Legacy conflict checking for tours
  // Use checkTemplateScheduleConflicts instead for template-first workflow

  /**
   * üõ°Ô∏è EDGE CASE HELPER: Check for active bookings
   */
  async checkActiveBookings(scheduleId) {
    try {
      const { data: bookings, error } = await supabase
        .from('bookings')
        .select('id, booking_status, commission_locked_at')
        .eq('schedule_id', scheduleId)
        .in('booking_status', ['pending', 'confirmed'])

      if (error) {
        console.error('Error checking active bookings:', error)  
        return { canModify: false, count: 0, reason: 'CHECK_FAILED' }
      }

      const activeCount = bookings ? bookings.length : 0
      const lockedCount = bookings ? bookings.filter(b => b.commission_locked_at).length : 0

      return {
        canModify: activeCount === 0,
        count: activeCount,
        lockedCount: lockedCount,
        reason: activeCount > 0 ? 'ACTIVE_BOOKINGS' : null
      }

    } catch (error) {
      console.error('Error in checkActiveBookings:', error)
      return { canModify: false, count: 0, reason: 'CHECK_ERROR' }
    }
  },

  /**
   * üõ°Ô∏è EDGE CASE HELPER: Detect date/time conflicts between schedules
   */
  detectDateTimeConflict(newSchedule, existingSchedule) {
    // Simplified conflict detection - can be expanded
    const newStart = new Date(newSchedule.start_date)
    const newEnd = new Date(newSchedule.end_date)
    const existingStart = new Date(existingSchedule.start_date)
    const existingEnd = new Date(existingSchedule.end_date)

    // Check for date range overlap
    const hasDateOverlap = newStart <= existingEnd && newEnd >= existingStart

    if (!hasDateOverlap) {
      return { hasConflict: false }
    }

    // For same recurrence type and overlapping dates, it's a conflict
    if (newSchedule.recurrence_type === existingSchedule.recurrence_type) {
      return { 
        hasConflict: true, 
        conflictDate: `${newSchedule.start_date}_${newSchedule.start_time}`
      }
    }

    return { hasConflict: false }
  },

  /**
   * ‚úÖ PHASE 3: Comprehensive validation for schedule data
   * @param {Object} scheduleData - The schedule data to validate
   * @param {boolean} isUpdate - Whether this is an update operation
   * @returns {Object} Validation result with valid flag and errors array (ERROR CODES for i18n)
   */
  validateScheduleData(scheduleData, isUpdate = false) {
    const errors = []

    try {
      // Required fields validation (skip for updates) - TEMPLATE-FIRST ONLY
      if (!isUpdate) {
        if (!scheduleData.template_id) errors.push('TEMPLATE_ID_REQUIRED')
        if (!scheduleData.operator_id) errors.push('OPERATOR_ID_REQUIRED')
      }

      if (!scheduleData.recurrence_type) {
        errors.push('RECURRENCE_TYPE_REQUIRED')
      }

      if (!scheduleData.start_time) {
        errors.push('START_TIME_REQUIRED')
      }

      if (!scheduleData.start_date) {
        errors.push('START_DATE_REQUIRED')
      }

      if (!scheduleData.end_date) {
        errors.push('END_DATE_REQUIRED')
      }

      // Recurrence type validation
      const validRecurrenceTypes = ['once', 'daily', 'weekly', 'monthly']
      if (scheduleData.recurrence_type && !validRecurrenceTypes.includes(scheduleData.recurrence_type)) {
        errors.push('INVALID_RECURRENCE_TYPE')
      }

      // Days of week validation
      if (scheduleData.days_of_week) {
        if (!Array.isArray(scheduleData.days_of_week)) {
          errors.push('DAYS_OF_WEEK_MUST_BE_ARRAY')
        } else {
          const invalidDays = scheduleData.days_of_week.filter(day => !Number.isInteger(day) || day < 1 || day > 7)
          if (invalidDays.length > 0) {
            errors.push('INVALID_DAYS_OF_WEEK')
          }
        }
      }

      // Weekly recurrence requires days_of_week
      if (scheduleData.recurrence_type === 'weekly' && (!scheduleData.days_of_week || scheduleData.days_of_week.length === 0)) {
        errors.push('WEEKLY_REQUIRES_DAYS')
      }

      // Time format validation (HH:MM)
      if (scheduleData.start_time) {
        const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/
        if (!timeRegex.test(scheduleData.start_time)) {
          errors.push('INVALID_TIME_FORMAT')
        }
      }

      // Date format validation (YYYY-MM-DD)
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/

      if (scheduleData.start_date && !dateRegex.test(scheduleData.start_date)) {
        errors.push('INVALID_START_DATE_FORMAT')
      }

      if (scheduleData.end_date && !dateRegex.test(scheduleData.end_date)) {
        errors.push('INVALID_END_DATE_FORMAT')
      }

      // Date logic validation
      if (scheduleData.start_date && scheduleData.end_date) {
        const startDate = new Date(scheduleData.start_date)
        const endDate = new Date(scheduleData.end_date)
        const today = new Date()
        today.setHours(0, 0, 0, 0) // Reset time for date comparison

        // Skip basic past date check for templates - auto-close validation handles timing

        if (endDate <= startDate) {
          errors.push('END_DATE_BEFORE_START')
        }

        // Reasonable date range limits (2 years max)
        const maxDateRange = 365 * 2 * 24 * 60 * 60 * 1000 // 2 years in milliseconds
        if (endDate - startDate > maxDateRange) {
          errors.push('DATE_RANGE_TOO_LARGE')
        }
      }

      // Exceptions validation
      if (scheduleData.exceptions) {
        if (!Array.isArray(scheduleData.exceptions)) {
          errors.push('EXCEPTIONS_MUST_BE_ARRAY')
        } else {
          const invalidExceptions = scheduleData.exceptions.filter(date => !dateRegex.test(date))
          if (invalidExceptions.length > 0) {
            errors.push('INVALID_EXCEPTION_DATES')
          }
        }
      }

      // UUID format validation (basic)
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i

      if (scheduleData.template_id && !uuidRegex.test(scheduleData.template_id)) {
        errors.push('INVALID_TEMPLATE_ID_FORMAT')
      }

      if (scheduleData.operator_id && !uuidRegex.test(scheduleData.operator_id)) {
        errors.push('INVALID_OPERATOR_ID_FORMAT')
      }

    } catch (error) {
      errors.push(`VALIDATION_ERROR|${error.message}`)
    }

    return {
      valid: errors.length === 0,
      errors: errors // Now returns error codes for i18n translation
    }
  },

  /**
   * ‚úÖ PHASE 3: Generate preview of tour instances that would be created by a schedule
   * @param {Object} scheduleData - The schedule data to preview
   * @param {number} limit - Maximum number of instances to preview (default: 10)
   * @returns {Array} Array of preview instances with dates and times
   */
  generateSchedulePreview(scheduleData, limit = 10) {
    try {
      const preview = []
      
      if (!scheduleData.start_date || !scheduleData.end_date || !scheduleData.recurrence_type) {
        return preview
      }

      // Timezone-safe date parsing using Polynesian timezone
      const startDate = parsePolynesianDate(scheduleData.start_date)
      const endDate = parsePolynesianDate(scheduleData.end_date)
      const exceptions = scheduleData.exceptions || []

      if (scheduleData.recurrence_type === 'once') {
        // One-time schedule
        const dateStr = scheduleData.start_date
        if (!exceptions.includes(dateStr)) {
          preview.push({
            date: dateStr,
            time: scheduleData.start_time,
            dayName: startDate.toLocaleDateString('en-US', { weekday: 'long' })
          })
        }
      } else if (scheduleData.recurrence_type === 'daily') {
        // Daily recurrence
        let currentDate = new Date(startDate)
        while (currentDate <= endDate && preview.length < limit) {
          const dateStr = formatPolynesianDateISO(currentDate)
          if (!exceptions.includes(dateStr)) {
            preview.push({
              date: dateStr,
              time: scheduleData.start_time,
              dayName: currentDate.toLocaleDateString('en-US', { weekday: 'long' })
            })
          }
          currentDate.setDate(currentDate.getDate() + 1)
        }
      } else if (scheduleData.recurrence_type === 'weekly') {
        // Weekly recurrence
        const daysOfWeek = scheduleData.days_of_week || []
        let currentDate = new Date(startDate)
        
        while (currentDate <= endDate && preview.length < limit) {
          const dayOfWeek = currentDate.getDay() === 0 ? 7 : currentDate.getDay() // Convert Sunday from 0 to 7
          
          if (daysOfWeek.includes(dayOfWeek)) {
            const dateStr = formatPolynesianDateISO(currentDate)
            if (!exceptions.includes(dateStr)) {
              preview.push({
                date: dateStr,
                time: scheduleData.start_time,
                dayName: currentDate.toLocaleDateString('en-US', { weekday: 'long' })
              })
            }
          }
          currentDate.setDate(currentDate.getDate() + 1)
        }
      } else if (scheduleData.recurrence_type === 'monthly') {
        // Monthly recurrence - same day of month
        let currentDate = new Date(startDate)
        const dayOfMonth = startDate.getDate()
        
        while (currentDate <= endDate && preview.length < limit) {
          if (currentDate.getDate() === dayOfMonth) {
            const dateStr = formatPolynesianDateISO(currentDate)
            if (!exceptions.includes(dateStr)) {
              preview.push({
                date: dateStr,
                time: scheduleData.start_time,
                dayName: currentDate.toLocaleDateString('en-US', { weekday: 'long' })
              })
            }
          }
          currentDate.setDate(currentDate.getDate() + 1)
        }
      }

      return preview.sort((a, b) => a.date.localeCompare(b.date))

    } catch (error) {
      console.error('Error generating schedule preview:', error)
      return []
    }
  },

  // ==============================================================================
  // PHASE 4: INDIVIDUAL TOUR MANAGEMENT FUNCTIONS
  // ==============================================================================

  /**
   * Get individual tour management dashboard for an operator
   * @param {string} operatorId - The operator ID
   * @param {Object} filters - Optional filters for date range, customization status, etc.
   * @returns {Promise<Array>} Array of tours with management information
   */
  async getTourManagementDashboard(operatorId, filters = {}) {
    try {
      console.log('üéØ Loading tour management dashboard for operator:', operatorId)

      let query = supabase
        .from('tour_management_dashboard')
        .select('*')
        .eq('operator_id', operatorId)

      // Apply filters
      if (filters.dateFrom) {
        query = query.gte('tour_date', filters.dateFrom)
      }
      if (filters.dateTo) {
        query = query.lte('tour_date', filters.dateTo)
      }
      if (filters.activityType) {
        query = query.eq('activity_type', filters.activityType)
      }
      if (filters.isCustomized !== undefined) {
        query = query.eq('is_customized', filters.isCustomized)
      }
      if (filters.scheduleId) {
        query = query.eq('parent_schedule_id', filters.scheduleId)
      }

      const { data: tours, error } = await query
        .order('tour_date', { ascending: true })
        .order('time_slot', { ascending: true })

      if (error) {
        console.error('Error fetching tour management dashboard:', error)
        throw error
      }

      console.log(`‚úÖ Loaded ${tours?.length || 0} tours for management`)
      return tours || []

    } catch (error) {
      console.error('Error in getTourManagementDashboard:', error)
      throw error
    }
  },

  /**
   * Apply individual customization to a tour
   * @param {string} tourId - The tour ID
   * @param {Object} customizations - The customizations to apply
   * @param {Array<string>} frozenFields - Fields to freeze from bulk updates
   * @returns {Promise<Object>} Result of customization
   */
  async customizeTour(tourId, customizations, frozenFields = []) {
    try {
      console.log('üé® Customizing tour:', tourId, customizations)

      // Validation
      if (!tourId) {
        throw new Error('TOUR_ID_REQUIRED')
      }
      if (!customizations || Object.keys(customizations).length === 0) {
        throw new Error('CUSTOMIZATIONS_REQUIRED')
      }

      // Call the database function
      const { data, error } = await supabase
        .rpc('apply_tour_customization', {
          tour_id_param: tourId,
          customizations: customizations,
          frozen_fields_param: frozenFields
        })

      if (error) {
        console.error('Error applying tour customization:', error)
        throw new Error(`CUSTOMIZATION_FAILED|${error.message}`)
      }

      if (!data || data.length === 0 || !data[0].success) {
        const message = data?.[0]?.message || 'Unknown error'
        throw new Error(`CUSTOMIZATION_FAILED|${message}`)
      }

      const result = data[0]
      console.log('‚úÖ Tour customization applied successfully')
      
      return {
        success: true,
        tour: result.tour_data,
        message: result.message
      }

    } catch (error) {
      console.error('Error in customizeTour:', error)
      throw error
    }
  },

  /**
   * Bulk update scheduled tours with override protection
   * @param {string} scheduleId - The schedule ID
   * @param {Object} updates - Updates to apply
   * @param {boolean} respectCustomizations - Whether to respect customizations (default: true)
   * @returns {Promise<Object>} Update results
   */
  async bulkUpdateScheduledTours(scheduleId, updates, respectCustomizations = true) {
    try {
      console.log('üîÑ Bulk updating scheduled tours:', scheduleId, updates)

      if (!scheduleId) {
        throw new Error('SCHEDULE_ID_REQUIRED')
      }
      if (!updates || Object.keys(updates).length === 0) {
        throw new Error('UPDATES_REQUIRED')
      }

      // Call the database function
      const { data, error } = await supabase
        .rpc('bulk_update_scheduled_tours', {
          schedule_id_param: scheduleId,
          updates: updates,
          respect_customizations: respectCustomizations
        })

      if (error) {
        console.error('Error in bulk update:', error)
        throw new Error(`BULK_UPDATE_FAILED|${error.message}`)
      }

      const result = data[0]
      console.log(`‚úÖ Bulk update completed: ${result.tours_updated} updated, ${result.tours_skipped} skipped`)
      
      return {
        success: true,
        toursUpdated: result.tours_updated,
        toursSkipped: result.tours_skipped,
        message: result.message
      }

    } catch (error) {
      console.error('Error in bulkUpdateScheduledTours:', error)
      throw error
    }
  },

  /**
   * Detach a tour from its schedule (make it independent)
   * @param {string} tourId - The tour ID
   * @returns {Promise<Object>} Detachment result
   */
  async detachTourFromSchedule(tourId) {
    try {
      console.log('üîì Detaching tour from schedule:', tourId)

      if (!tourId) {
        throw new Error('TOUR_ID_REQUIRED')
      }

      // Call the database function
      const { data, error } = await supabase
        .rpc('detach_tour_from_schedule', {
          tour_id_param: tourId
        })

      if (error) {
        console.error('Error detaching tour:', error)
        throw new Error(`DETACH_FAILED|${error.message}`)
      }

      if (!data || data.length === 0 || !data[0].success) {
        const message = data?.[0]?.message || 'Unknown error'
        throw new Error(`DETACH_FAILED|${message}`)
      }

      const result = data[0]
      console.log('‚úÖ Tour detached successfully')
      
      return {
        success: true,
        message: result.message
      }

    } catch (error) {
      console.error('Error in detachTourFromSchedule:', error)
      throw error
    }
  },

  /**
   * Reset tour customizations (make it follow schedule again)
   * @param {string} tourId - The tour ID
   * @returns {Promise<Object>} Reset result
   */
  async resetTourCustomizations(tourId) {
    try {
      console.log('üîÑ Resetting tour customizations:', tourId)

      if (!tourId) {
        throw new Error('TOUR_ID_REQUIRED')
      }

      // Reset customization flags and data
      const { data: tour, error } = await supabase
        .from('tours')
        .update({
          is_customized: false,
          frozen_fields: [],
          overrides: {},
          customization_timestamp: null,
          promo_discount_percent: null,
          promo_discount_value: null,
          instance_note: null,
          updated_at: new Date().toISOString()
        })
        .eq('id', tourId)
        .eq('is_template', false)
        .select()
        .single()

      if (error) {
        console.error('Error resetting tour customizations:', error)
        throw new Error(`RESET_FAILED|${error.message}`)
      }

      console.log('‚úÖ Tour customizations reset successfully')
      
      return {
        success: true,
        tour: tour,
        message: 'Tour customizations reset. Tour will now follow schedule updates.'
      }

    } catch (error) {
      console.error('Error in resetTourCustomizations:', error)
      throw error
    }
  },

  /**
   * Get scheduled tours for a specific schedule with customization status
   * @param {string} scheduleId - The schedule ID
   * @param {Object} options - Query options
   * @returns {Promise<Array>} Array of scheduled tours
   */
  async getScheduledToursForSchedule(scheduleId, options = {}) {
    try {
      console.log('üìã Loading scheduled tours for schedule:', scheduleId)

      if (!scheduleId) {
        throw new Error('SCHEDULE_ID_REQUIRED')
      }

      let query = supabase
        .from('tours')
        .select(`
          *,
          parent_template:parent_template_id(tour_name, tour_type)
        `)
        .eq('parent_schedule_id', scheduleId)
        .eq('activity_type', 'scheduled')

      // Apply date filters
      if (options.dateFrom) {
        query = query.gte('tour_date', options.dateFrom)
      }
      if (options.dateTo) {
        query = query.lte('tour_date', options.dateTo)
      }

      // Apply status filters
      if (options.status) {
        query = query.eq('status', options.status)
      }

      const { data: tours, error } = await query
        .order('tour_date', { ascending: true })
        .order('time_slot', { ascending: true })

      if (error) {
        console.error('Error fetching scheduled tours:', error)
        throw error
      }

      console.log(`‚úÖ Loaded ${tours?.length || 0} scheduled tours`)
      return tours || []

    } catch (error) {
      console.error('Error in getScheduledToursForSchedule:', error)
      throw error
    }
  },

  /**
   * Get tour customization history and details
   * @param {string} tourId - The tour ID
   * @returns {Promise<Object>} Tour details with customization info
   */
  async getTourCustomizationDetails(tourId) {
    try {
      console.log('üîç Loading tour customization details:', tourId)

      if (!tourId) {
        throw new Error('TOUR_ID_REQUIRED')
      }

      const { data: tour, error } = await supabase
        .from('tour_management_dashboard')
        .select('*')
        .eq('id', tourId)
        .single()

      if (error) {
        console.error('Error fetching tour customization details:', error)
        throw error
      }

      if (!tour) {
        throw new Error('TOUR_NOT_FOUND')
      }

      console.log('‚úÖ Tour customization details loaded')
      return tour

    } catch (error) {
      console.error('Error in getTourCustomizationDetails:', error)
      throw error
    }
  },

  /**
   * Validate tour customization data
   * @param {Object} customizations - The customizations to validate
   * @returns {Object} Validation result
   */
  validateTourCustomizations(customizations) {
    const errors = []

    try {
      // Price validations
      if (customizations.discount_price_adult !== undefined) {
        if (typeof customizations.discount_price_adult !== 'number' || customizations.discount_price_adult < 0) {
          errors.push('INVALID_ADULT_PRICE')
        }
      }

      if (customizations.discount_price_child !== undefined) {
        if (customizations.discount_price_child !== null && 
            (typeof customizations.discount_price_child !== 'number' || customizations.discount_price_child < 0)) {
          errors.push('INVALID_CHILD_PRICE')
        }
      }

      // Capacity validations
      if (customizations.max_capacity !== undefined) {
        if (typeof customizations.max_capacity !== 'number' || customizations.max_capacity <= 0 || customizations.max_capacity > 100) {
          errors.push('INVALID_CAPACITY')
        }
      }

      // Promo discount validations
      if (customizations.promo_discount_percent !== undefined) {
        if (customizations.promo_discount_percent !== null &&
            (typeof customizations.promo_discount_percent !== 'number' || 
             customizations.promo_discount_percent < 0 || 
             customizations.promo_discount_percent > 100)) {
          errors.push('INVALID_PROMO_PERCENT')
        }
      }

      if (customizations.promo_discount_value !== undefined) {
        if (customizations.promo_discount_value !== null &&
            (typeof customizations.promo_discount_value !== 'number' || customizations.promo_discount_value < 0)) {
          errors.push('INVALID_PROMO_VALUE')
        }
      }

      // Status validations
      if (customizations.status !== undefined) {
        const validStatuses = ['active', 'sold_out', 'cancelled', 'completed', 'paused', 'hidden']
        if (!validStatuses.includes(customizations.status)) {
          errors.push('INVALID_STATUS')
        }
      }

      // Text field validations
      if (customizations.instance_note !== undefined) {
        if (typeof customizations.instance_note !== 'string' || customizations.instance_note.length > 1000) {
          errors.push('INVALID_INSTANCE_NOTE')
        }
      }

      if (customizations.meeting_point !== undefined) {
        if (typeof customizations.meeting_point !== 'string' || customizations.meeting_point.length > 255) {
          errors.push('INVALID_MEETING_POINT')
        }
      }

    } catch (error) {
      errors.push(`VALIDATION_ERROR|${error.message}`)
    }

    return {
      valid: errors.length === 0,
      errors: errors
    }
  }

}

